diff --git a/tensorflow_serving/util/net_http/server/internal/evhttp_request.cc b/tensorflow_serving/util/net_http/server/internal/evhttp_request.cc
index c8d0501b..d8e6f9de 100644
--- a/tensorflow_serving/util/net_http/server/internal/evhttp_request.cc
+++ b/tensorflow_serving/util/net_http/server/internal/evhttp_request.cc
@@ -25,6 +25,8 @@ limitations under the License.
 #include <cstring>
 #include <string>
 #include <vector>
+#include <iostream>
+
 
 #include "absl/strings/match.h"
 #include "absl/strings/string_view.h"
@@ -143,6 +145,24 @@ bool EvHTTPRequest::Initialize() {
   return output_buf != nullptr;
 }
 
+void escapeSpecialCharacters(const char* input) {
+    std::cout << "NET_HTTP: => [";
+    while (*input) {
+        switch (*input) {
+            case '\r':
+                std::cout << "\\r";
+                break;
+            case '\n':
+                std::cout << "\\n";
+                break;
+            default:
+                std::cout << *input;
+        }
+        ++input;
+    }
+    std::cout << "]\n";
+}
+
 void EvHTTPRequest::WriteResponseBytes(const char* data, int64_t size) {
   assert(size >= 0);
   if (output_buf == nullptr) {
@@ -150,6 +170,8 @@ void EvHTTPRequest::WriteResponseBytes(const char* data, int64_t size) {
     return;
   }
 
+//  NET_LOG(ERROR, "Writing to buf: [%s]", data);
+  //escapeSpecialCharacters(data);
   int ret = evbuffer_add(output_buf, data, static_cast<size_t>(size));
   if (ret == -1) {
     NET_LOG(ERROR, "Failed to write %zu bytes data to output buffer",
@@ -339,11 +361,19 @@ void EvHTTPRequest::AppendResponseHeader(absl::string_view header,
 }
 
 void EvHTTPRequest::PartialReplyWithStatus(HTTPStatusCode status) {
-  NET_LOG(FATAL, "PartialReplyWithStatus not implemented.");
+  bool result =
+      server_->EventLoopSchedule([this, status]() { EvPartialSendReply(status); });
+
+  if (!result) {
+    NET_LOG(ERROR, "Failed to EventLoopSchedule PartialReplyWithStatus()");
+    Abort();
+    // TODO(wenboz): should have a forced abort that doesn't write back anything
+    // to the event-loop
+  }
 }
 
 void EvHTTPRequest::PartialReply() {
-  NET_LOG(FATAL, "PartialReplyWithStatus not implemented.");
+  PartialReplyWithStatus(HTTPStatusCode::OK);
 }
 
 ServerRequestInterface::CallbackStatus
@@ -371,6 +401,24 @@ void EvHTTPRequest::EvSendReply(HTTPStatusCode status) {
   delete this;
 }
 
+void EvHTTPRequest::EvPartialSendReply(HTTPStatusCode status) {
+  if (!this->is_reply_started_) {
+    evhttp_send_reply_start(parsed_request_->request, static_cast<int>(status), "reply start");
+    this->is_reply_started_ = true;
+  }
+  evhttp_send_reply_chunk(parsed_request_->request, output_buf);
+}
+
+void EvHTTPRequest::EvPartialReplyEnd() {
+  if (!this->is_reply_started_) {
+    // Start before we end can end the reply
+    evhttp_send_reply_start(parsed_request_->request, HTTP_OK, "no messages");
+  }
+  evhttp_send_reply_end(parsed_request_->request);
+  server_->DecOps();
+  delete this;
+}
+
 void EvHTTPRequest::Reply() { ReplyWithStatus(HTTPStatusCode::OK); }
 
 // Treats this as 500 for now and let libevent decide what to do
@@ -381,6 +429,18 @@ void EvHTTPRequest::Abort() {
   delete this;
 }
 
+void EvHTTPRequest::PartialReplyEnd() {
+  bool result =
+      server_->EventLoopSchedule([this]() { EvPartialReplyEnd(); });
+
+  if (!result) {
+    NET_LOG(ERROR, "Failed to EventLoopSchedule PartialReplyEnd()");
+    Abort();
+    // TODO(wenboz): should have a forced abort that doesn't write back anything
+    // to the event-loop
+  }
+}
+
 }  // namespace net_http
 }  // namespace serving
 }  // namespace tensorflow
diff --git a/tensorflow_serving/util/net_http/server/internal/evhttp_request.h b/tensorflow_serving/util/net_http/server/internal/evhttp_request.h
index 2f8e601d..71736175 100644
--- a/tensorflow_serving/util/net_http/server/internal/evhttp_request.h
+++ b/tensorflow_serving/util/net_http/server/internal/evhttp_request.h
@@ -104,6 +104,8 @@ class EvHTTPRequest final : public ServerRequestInterface {
 
   void Abort() override;
 
+  void PartialReplyEnd() override;
+
   // Initializes the resource and returns false if any error.
   bool Initialize();
 
@@ -114,6 +116,8 @@ class EvHTTPRequest final : public ServerRequestInterface {
 
  private:
   void EvSendReply(HTTPStatusCode status);
+  void EvPartialSendReply(HTTPStatusCode status);
+  void EvPartialReplyEnd();
 
   // Returns true if the data needs be uncompressed
   bool NeedUncompressGzipContent();
@@ -133,6 +137,8 @@ class EvHTTPRequest final : public ServerRequestInterface {
   std::unique_ptr<ParsedEvRequest> parsed_request_;
 
   evbuffer* output_buf;  // owned by this
+
+  bool is_reply_started_{false};
 };
 
 }  // namespace net_http
diff --git a/tensorflow_serving/util/net_http/server/public/server_request_interface.h b/tensorflow_serving/util/net_http/server/public/server_request_interface.h
index e5f4b05f..fa462f8a 100644
--- a/tensorflow_serving/util/net_http/server/public/server_request_interface.h
+++ b/tensorflow_serving/util/net_http/server/public/server_request_interface.h
@@ -182,6 +182,8 @@ class ServerRequestInterface {
   // by the server runtime.
   virtual void Abort() = 0;
 
+  virtual void PartialReplyEnd() = 0;
+
  protected:
   ServerRequestInterface() = default;
 
